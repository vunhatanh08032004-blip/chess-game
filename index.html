<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Chess Master - Pro Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <style>
        body {
            background: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Arial;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .top-controls {
            margin-bottom: 20px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .mode-btn {
            padding: 12px 25px;
            cursor: pointer;
            font-weight: bold;
            background: #444;
            color: #ccc;
            border: none;
            margin: 0 5px;
            border-radius: 4px;
        }

            .mode-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        .btn-active {
            background: #007acc !important;
            color: white !important;
        }

        #game-view-container {
            transition: 0.3s;
            filter: grayscale(1);
            opacity: 0.3;
            pointer-events: none;
        }

        .is-active {
            filter: grayscale(0) !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        #main-layout {
            display: flex;
            gap: 20px;
            background: #262626;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #game-outer {
            position: relative;
            width: 450px;
            height: 450px;
        }

        #board {
            width: 100%;
            height: 100%;
        }

        #click-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            z-index: 1000;
        }

        .click-cell {
            width: 100%;
            height: 100%;
            cursor: pointer;
            border: 2px solid transparent;
            box-sizing: border-box;
        }

        .border-selected {
            background: rgba(255, 255, 0, 0.4);
            border: 2px solid yellow !important;
        }

        .border-hint {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid lime !important;
        }

        .in-check {
            background: rgba(255, 0, 0, 0.7) !important;
            border: 3px solid red !important;
            animation: blink 0.6s infinite;
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .info-bar {
            margin: 10px 0;
            padding: 10px;
            background: #111;
            text-align: center;
            color: #00ffcc;
            font-weight: bold;
            border-radius: 4px;
        }

        #logs {
            width: 280px;
            background: #000;
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            font-size: 13px;
            border-radius: 4px;
        }

        .system-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            background: #fff;
            color: #000;
            z-index: 3000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .modal-header {
            background: #0055ea;
            color: #fff;
            padding: 12px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-x {
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 0 5px;
        }

        .modal-body {
            padding: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1em;
        }

        .modal-footer {
            padding: 10px;
            background: #eee;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 20px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            background: #0055ea;
            color: white;
            border-radius: 4px;
        }

        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2999;
        }


        /* Màu sắc cho Log */
        .log-user {
            color: #ffffff;
        }


        /* Trắng: Người chơi */
        .log-opponent {
            color: #00ccff;
        }


        /* Xanh: Máy/Đối thủ */
        .log-system {
            color: #ffcc00;
        }


        /* Vàng: Hệ thống */
        .log-score {
            color: #ff4444;
        }


        /* Đỏ: Điểm số/Cảnh báo */

    </style>
</head>
<body>

    <div class="top-controls">
        <button class="mode-btn" id="btn-pve" onclick="requestGame('PVE')">NGƯỜI VS MÁY</button>
        <button class="mode-btn" id="btn-pvp" onclick="requestGame('PVP')">NGƯỜI VS NGƯỜI</button>
    </div>

    <div id="game-view-container">
        <div id="main-layout">
            <div>
                <div id="game-outer"><div id="board"></div><div id="click-overlay"></div></div>
                <div class="info-bar">
                    <span id="turn-display">LƯỢT: TRẮNG</span> | <span id="timer-span">30s</span>
                </div>
            </div>
            <div id="side-panel">
                <div id="logs"></div>
                <button onclick="confirmExit()" style="margin-top:10px; background:#e74c3c; color:white; border:none; padding:12px; cursor:pointer; font-weight:bold; width:100%; border-radius:4px;">THOÁT</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay"></div>
    <div id="custom-modal" class="system-modal">
        <div class="modal-header">
            <span id="modal-title">HỆ THỐNG</span>
            <span class="close-x" onclick="closeSystemModal()">&times;</span>
        </div>
        <div class="modal-body" id="modal-msg"></div>
        <div class="modal-footer" id="modal-btns"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCJRXRhYXBbc0DiwZg3KXnySGJ63z4Ow2s",
            authDomain: "chessonline-43534.firebaseapp.com",
            databaseURL: "https://chessonline-43534-default-rtdb.firebaseio.com",
            projectId: "chessonline-43534",
            storageBucket: "chessonline-43534.firebasestorage.app",
            messagingSenderId: "194591877060",
            appId: "1:194591877060:web:4d9461cbebfc3184eb2691"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const myId = "UID-" + Math.random().toString(36).substr(2, 5);

        var board = null, game = new Chess(), selectedSq = null;
        var mode = '', myColor = 'w', timer = 30, timerInt = null, isPaused = false;
        var matchmakingTimer = null;
        var aiRecentSquares = [];

        // Cập nhật hàm addLog để hỗ trợ màu sắc và thời gian
        function addLog(msg, type = 'system') {
            const now = new Date();
            const timeStr = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;

            let colorClass = 'log-system';
            if (type === 'user') colorClass = 'log-user';
            if (type === 'opponent') colorClass = 'log-opponent';

            $('#logs').append(`<div class="${colorClass}">${timeStr} ➔ ${msg}</div>`);
            $('#logs').scrollTop($('#logs')[0].scrollHeight);
        }

        function triggerModal(msg, btns, title = "HỆ THỐNG") {
            isPaused = true;
            $('#modal-title').text(title);
            $('#modal-msg').html(msg);
            $('#modal-btns').html(btns.map(x => `<button class="modal-btn" onclick="${x.fn}">${x.txt}</button>`).join(''));
            $('#modal-overlay, #custom-modal').show();
        }

        function closeSystemModal() {
            $('#modal-overlay, #custom-modal').hide();
            if (matchmakingTimer) clearInterval(matchmakingTimer);
            isPaused = false;
            $('#game-view-container').addClass('is-active');
            if (mode && !timerInt) startCountdown();
        }

        function confirmExit() {
            triggerModal("Bạn có thực sự muốn thoát không?", [
                { txt: "Thoát", fn: "exitGame()" },
                { txt: "Ở lại", fn: "closeSystemModal()" }
            ], "XÁC NHẬN");
        }

        function requestGame(m) {
            // Reset tất cả các nút về trạng thái bình thường
            $('.mode-btn').removeClass('btn-active').css({
                'opacity': '0.5',
                'pointer-events': 'auto' // Cho phép chọn lại nếu muốn
            });

            // Làm sáng rực nút được chọn và giữ nó không bị mờ
            $(`#btn-${m.toLowerCase()}`).addClass('btn-active').css({
                'opacity': '1',
                'pointer-events': 'none' // Khóa nút sau khi đã chọn
            });

            if (m === 'PVP') {
                let secondsLeft = 60;
                triggerModal(`Đang tìm đối thủ... <br><span style="font-size:2em; color:#0055ea;" id="mm-countdown">60</span>`, [], "GHÉP TRẬN");
                matchmakingTimer = setInterval(() => {
                    secondsLeft--;
                    $('#mm-countdown').text(secondsLeft);
                    if (secondsLeft <= 0) {
                        clearInterval(matchmakingTimer);
                        triggerModal("Không có đối thủ nào đang chơi!", [{ txt: "Quay lại", fn: "exitGame()" }]);
                    }
                }, 1000);

                const lobbyRef = db.ref('matchmaking');
                const myStatusRef = lobbyRef.child(myId);
                myStatusRef.set({ id: myId, ts: Date.now() });
                const hb = setInterval(() => myStatusRef.update({ ts: Date.now() }), 2000);
                myStatusRef.onDisconnect().remove();

                lobbyRef.once('value', (snap) => {
                    let found = false;
                    snap.forEach((child) => {
                        const peer = child.val();
                        if (peer.id !== myId && (Date.now() - peer.ts < 5000)) {
                            found = true;
                            clearInterval(hb); clearInterval(matchmakingTimer);
                            myColor = 'b';
                            db.ref('rooms/' + peer.id).set({ fen: 'start', p1: peer.id, p2: myId });
                            triggerModal("Đã tìm thấy đối thủ!", [{ txt: "Bắt đầu ngay", fn: "startGamePVP('" + peer.id + "')" }]);
                        }
                    });
                    if (!found) {
                        db.ref('rooms/' + myId).on('value', s => {
                            if (s.exists() && s.val().p2) {
                                clearInterval(hb); clearInterval(matchmakingTimer);
                                db.ref('rooms/' + myId).off();
                                myColor = 'w';
                                triggerModal("Đã tìm thấy đối thủ!", [{ txt: "Bắt đầu ngay", fn: "startGamePVP('" + myId + "')" }]);
                            }
                        });
                    }
                });
            } else {
                triggerModal("Bắt đầu chế độ người với máy", [{ txt: "Bắt đầu", fn: "initGame('PVE')" }]);
            }
        }

        function startGamePVP(roomId) {
            window.currentRoom = roomId;
            db.ref('rooms/' + roomId).on('value', snap => {
                const data = snap.val();
                if (data && data.fen !== game.fen()) {
                    game.load(data.fen);
                    board.position(data.fen);
                    refreshStatus();
                }
            });
            initGame('PVP');
        }

        // --- AI NÂNG CẤP: CHỐNG LẶP LẠI & TẤN CÔNG CHỦ ĐỘNG ---
        const pieceValues = { p: 100, r: 520, n: 330, b: 330, q: 900, k: 20000 };

        function minimax(g, depth, isMax, alpha, beta) {
            if (depth === 0) return -evaluateBoard(g);
            let moves = g.moves();

            // Sắp xếp ưu tiên: Chiếu tướng > Ăn quân > Tiến lên
            moves.sort((a, b) => {
                let sA = (a.includes('+') ? 20 : 0) + (a.includes('x') ? 15 : 0);
                let sB = (b.includes('+') ? 20 : 0) + (b.includes('x') ? 15 : 0);
                return sB - sA;
            });

            if (isMax) {
                let best = -2000000;
                for (let m of moves) {
                    g.move(m);
                    let score = minimax(g, depth - 1, false, alpha, beta);

                    // SỬA TẠI ĐÂY: Phạt nếu ô đích 'to' trùng với các ô máy vừa đi 2 lượt trước
                    if (aiRecentSquares.includes(m.to)) {
                        score -= 150; // Phạt điểm để máy ưu tiên ô khác/quân khác
                    }

                    g.undo();
                    best = Math.max(best, score);
                    alpha = Math.max(alpha, best);
                    if (beta <= alpha) break;
                }
                return best;
            } else {
                let best = 2000000;
                for (let m of moves) {
                    g.move(m);
                    let score = minimax(g, depth - 1, true, alpha, beta);
                    g.undo();
                    best = Math.min(best, score);
                    beta = Math.min(beta, best);
                    if (beta <= alpha) break;
                }
                return best;
            }
        }

        // Xóa aiMoveHistory và pieceMoveHistory cũ, thay bằng:
        var aiRecentSquares = [];

        function evaluateBoard(g) {
            if (g.in_checkmate()) return g.turn() === 'w' ? -100000 : 100000;
            let totalScore = 0;
            const board = g.board();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        let val = pieceValues[piece.type] || 0;

                        // Tăng thưởng điểm vị trí (Position Bonus)
                        if (piece.color === 'b') { // Giả sử AI là quân Đen
                            val += (i * 20); // i càng lớn là càng tiến về phía Trắng
                        } else {
                            val += ((7 - i) * 20);
                        }

                        totalScore += (piece.color === 'w' ? val : -val);
                    }
                }
            }
            return totalScore;
        }

        function aiMove() {
            if (game.game_over()) return;

            // Chỉnh sửa: Máy sẽ quyết định đánh khi timer nằm trong khoảng 30s đến 23s
            // (tương đương 0-7 giây sau khi bắt đầu lượt)
            const targetTimer = Math.floor(Math.random() * (30 - 23 + 1)) + 23;

            function processAILogic() {
                // Nếu thời gian còn lại chưa chạm tới mốc ngẫu nhiên (30-23s), tiếp tục chờ
                if (timer > targetTimer) {
                    setTimeout(processAILogic, 150); // Giải phóng CPU để Timer chạy mượt mà
                    return;
                }

                let moves = game.moves({ verbose: true });
                let bestMove = null;
                let bestVal = -Infinity;
                let index = 0;

                function processEachMove() {
                    if (index < moves.length) {
                        let m = moves[index];
                        game.move(m);

                        let val = calculateTacticalScore(m, game);
                        val += minimax(game, 2, false, -Infinity, Infinity);

                        if (aiRecentSquares.includes(m.to)) {
                            val -= 2000;
                        }

                        game.undo();

                        if (val > bestVal) {
                            bestVal = val;
                            bestMove = m;
                        }
                        index++;
                        // setTimeout(..., 1) giúp chia nhỏ tác vụ để không làm treo UI/Timer
                        setTimeout(processEachMove, 1);
                    } else {
                        if (!bestMove) bestMove = moves[0];

                        aiRecentSquares.push(bestMove.to);
                        if (aiRecentSquares.length > 4) aiRecentSquares.shift();

                        executeMove(bestMove);
                    }
                }
                processEachMove();
            }
            processAILogic();
        }

        function calculateTacticalScore(move, g) {
            let score = 0;
            const attackerVal = pieceValues[move.piece];

            // 1. Phân tích giá trị Ăn quân & Đổi quân
            if (move.captured) {
                const victimVal = pieceValues[move.captured];
                // TH: Tốt ăn quân lớn (Ví dụ: Tốt ăn Xe) -> Rất Tốt
                if (attackerVal < victimVal) {
                    score += (victimVal * 2);
                }
                // TH: Quân lớn ăn quân nhỏ (Ví dụ: Hậu ăn Tốt)
                else if (attackerVal > victimVal) {
                    // Nếu sau khi ăn mà bị ăn lại ngay lập tức -> Phạt nặng
                    if (isSquareAttacked(move.to, g)) {
                        score -= attackerVal;
                    } else {
                        score += victimVal;
                    }
                }
            }

            // 2. Logic Chiếu tướng & Tấn công an toàn (Đã xóa cảnh báo)
            if (g.in_check()) {
                // Nếu chiếu bí -> Thắng luôn
                if (g.in_checkmate()) {
                    score += 20000;
                } else {
                    // Kiểm tra nếu quân thực hiện chiếu tướng bị đe dọa ăn lại
                    if (isSquareAttacked(move.to, g)) {
                        // Trừ điểm nặng để máy tìm quân khác hoặc nước đi khác an toàn hơn
                        score -= (attackerVal * 1.5);
                    } else {
                        // Chiếu tướng an toàn hoặc có bảo vệ -> Thưởng điểm tấn công
                        score += 1200;
                    }
                }
            }

            // 3. Điểm thưởng cho việc bao vây Vua đối phương
            score += controlNearKing(g);

            return score;
        }

        // Hàm hỗ trợ: Đo mức độ bao vây quanh Vua đối thủ
        function controlNearKing(g) {
            let bonus = 0;
            const kingSq = findKing(g.turn());
            const moves = g.moves({ verbose: true });

            moves.forEach(m => {
                // Tính khoảng cách từ nước đi tới Vua đối phương
                const distance = Math.abs(m.to.charCodeAt(0) - kingSq.charCodeAt(0)) +
                    Math.abs(m.to.charCodeAt(1) - kingSq.charCodeAt(1));
                // Nếu quân cờ áp sát hoặc kiểm soát các ô gần Vua (trong phạm vi 2 ô)
                if (distance <= 2) bonus += 50;
            });
            return bonus;
        }

        // Hàm kiểm tra ô có bị tấn công không (để tránh đưa quân quan trọng vào chỗ chết)
        function isSquareAttacked(sq, g) {
            const moves = g.moves({ verbose: true });
            return moves.some(m => m.to === sq);
        }

        // Hàm kiểm tra ô có bị tấn công không (để tránh đưa quân quan trọng vào chỗ chết)
        function isSquareAttacked(sq, g) {
            const moves = g.moves({ verbose: true });
            return moves.some(m => m.to === sq);
        }

        // Hàm tính toán giá trị chiến thuật của nước đi (Ăn quân & Đổi quân)
        function evaluateMoveTactics(move, g) {
            let score = 0;

            // 1. Nếu ăn quân
            if (move.captured) {
                let victimValue = pieceValues[move.captured];
                let attackerValue = pieceValues[move.piece];

                // TH1: Tốt ăn quân lớn (ví dụ Tốt ăn Xe) -> Rất tốt
                if (attackerValue < victimValue) {
                    score += (victimValue - attackerValue) * 10;
                }

                // TH2: Quân lớn ăn quân nhỏ (ví dụ Hậu ăn Tốt)
                // Ta cần kiểm tra xem ô đó có bị quân địch canh giữ không
                if (attackerValue > victimValue) {
                    // Nếu sau khi ăn, quân đó bị đối phương ăn lại (giá trị âm lớn)
                    // Nhưng nếu tạo ra thế chiếu tướng/bí thì vẫn cộng điểm
                    if (g.in_check()) score += 500;
                    if (g.in_checkmate()) score += 10000;
                }
            }

            // Ưu tiên chiếu tướng và dồn thế bí
            if (g.in_check()) score += 300;
            if (g.in_checkmate()) score += 5000;

            return score;
        }

        // Cập nhật hàm executeMove để log chi tiết việc ăn quân
        function executeMove(move) {
            const m = game.move(move);
            if (!m) return;

            board.position(game.fen());

            // Xác định ai vừa đi để gán màu log
            const isMyMove = (m.color === myColor[0]);
            const role = isMyMove ? 'user' : 'opponent';
            const name = isMyMove ? 'BẠN' : (mode === 'PVE' ? 'MÁY' : 'ĐỐI THỦ');

            // Log nước đi kèm điểm đánh giá giả lập (giống hình ảnh)
            const scoreEval = Math.floor(Math.random() * 50);
            let moveMsg = `${name} đi: ${m.from}→${m.to} <span class="log-score">(Score Eval: ${scoreEval})</span>`;

            if (m.captured) {
                moveMsg += ` <b style="color:#ff4444;">- ĐÃ ĂN QUÂN</b>`;
            }

            addLog(moveMsg, role);

            // Kiểm tra chiếu tướng sau nước đi
            if (game.in_check()) {
                addLog(`CẢNH BÁO: VUA ${game.turn() === 'w' ? 'TRẮNG' : 'ĐEN'} ĐANG BỊ CHIẾU!`, 'system');
            }

            if (mode === 'PVP') db.ref('rooms/' + window.currentRoom).update({ fen: game.fen() });

            timer = 30;
            $('#timer-span').text(timer + "s");
            refreshStatus();

            if (mode === 'PVE' && game.turn() !== myColor) {
                // AI suy nghĩ nhưng không làm treo timer
                setTimeout(aiMove, 500);
            }
        }

        // Cập nhật refreshStatus để báo kết quả chi tiết
        function refreshStatus() {
            $('.click-cell').removeClass('in-check');
            $('#turn-display').text("LƯỢT: " + (game.turn() === 'w' ? "TRẮNG" : "ĐEN"));

            if (game.in_check()) $(`#sq-${findKing(game.turn())}`).addClass('in-check');

            if (game.game_over()) {
                clearInterval(timerInt);
                let msg = "";
                if (game.in_checkmate()) {
                    let winner = (game.turn() === 'w' ? "ĐEN" : "TRẮNG");
                    msg = `CHIẾU BÍ! QUÂN ${winner} THẮNG.`;
                    addLog(`HẾT TRẬN: ${msg}`, 'system');
                } else if (game.in_draw()) {
                    msg = "HÒA CỜ (Hết nước đi hoặc lặp lại)!";
                    addLog(`HẾT TRẬN: ${msg}`, 'system');
                }
                triggerModal(msg, [{ txt: "Quay lại", fn: "exitGame()" }], "KẾT QUẢ");
            }
        }

        function findKing(c) {
            for (let i = 0; i < 8; i++) for (let j = 0; j < 8; j++) {
                let s = String.fromCharCode(97 + j) + (i + 1);
                let p = game.get(s);
                if (p && p.type === 'k' && p.color === c) return s;
            }
        }

        function startCountdown() {
            if (timerInt) clearInterval(timerInt);
            timer = 30;
            $('#timer-span').show().text(timer + "s");
            timerInt = setInterval(() => {
                if (!isPaused) {
                    timer--;
                    $('#timer-span').text(timer + "s");
                    if (timer <= 0) {
                        if (game.turn() === myColor) {
                            let moves = game.moves();
                            if (moves.length > 0) executeMove(moves[0]);
                        }
                    }
                }
            }, 1000);
        }

        $(document).on('click', '.click-cell', function () {
            if (game.turn() !== myColor || isPaused) return;
            const sq = $(this).attr('data-sq');
            if (selectedSq) {
                const move = game.move({ from: selectedSq, to: sq, promotion: 'q' });
                if (move) { game.undo(); executeMove(move); selectedSq = null; $('.click-cell').removeClass('border-selected border-hint'); }
                else { selectPiece(sq); }
            } else { selectPiece(sq); }
        });

        function selectPiece(sq) {
            const p = game.get(sq);
            if (p && p.color === myColor && p.color === game.turn()) {
                selectedSq = sq;
                $('.click-cell').removeClass('border-selected border-hint');
                $(`#sq-${sq}`).addClass('border-selected');
                game.moves({ square: sq, verbose: true }).forEach(m => $(`#sq-${m.to}`).addClass('border-hint'));
            }
        }

        function drawClickGrid() {
            $('#click-overlay').empty();
            let sqs = [];
            for (let i = 8; i >= 1; i--) for (let j = 0; j < 8; j++) sqs.push(String.fromCharCode(97 + j) + i);
            if (myColor === 'b') sqs.reverse();
            sqs.forEach(s => $('#click-overlay').append(`<div class="click-cell" id="sq-${s}" data-sq="${s}"></div>`));
        }

        // Cập nhật khởi tạo game để log chế độ
        function initGame(m) {
            mode = m;
            game.reset();
            aiRecentSquares = [];
            if (m === 'PVE') {
                myColor = Math.random() > 0.5 ? 'w' : 'b';
                addLog(`CHẾ ĐỘ: NGƯỜI VS MÁY - Bạn cầm quân ${myColor === 'w' ? 'TRẮNG' : 'ĐEN'}`, 'system');
            } else {
                addLog(`CHẾ ĐỘ: NGƯỜI VS NGƯỜI - Trận đấu bắt đầu!`, 'system');
            }

            board.orientation(myColor === 'w' ? 'white' : 'black');
            board.start();
            drawClickGrid();
            closeSystemModal();
            refreshStatus();
            if (myColor === 'b' && m === 'PVE') setTimeout(aiMove, 1000);
        }

        function exitGame() {
            db.ref('matchmaking/' + myId).remove();
            if (window.currentRoom) db.ref('rooms/' + window.currentRoom).remove();
            location.reload();
        }

        board = Chessboard('board', { position: 'start', draggable: false, pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png' });
    </script>
</body>
</html>
